# 简历上传页面条件筛选问题修复计划

## 一、问题概述

简历上传页面的条件筛选功能未被正确执行，经过深入排查，发现存在**多个层面的问题**，需要从前端到后端全链路修复。

## 二、问题根源分析

### 2.1 核心问题：前端只传递第一个条件 ID

**问题位置**: [upload.js:876-883](file:///d:/Documents/CodeProjects/ResumeScreening/frontend-new/js/pages/upload.js#L876-L883)

```javascript
// 获取第一个条件 ID（向后兼容）
const firstConditionId = this.conditionGroups[0]?.conditionIds[0] || null;

// 统一使用批量上传接口
const response = await talentsApi.batchUpload(
    this.uploadedFiles,
    firstConditionId  // ❌ 只传了第一个条件 ID！
);
```

**问题描述**:
- 前端构建器已经正确实现了复杂筛选配置的构建逻辑（`getFilterConfig()` 方法）
- 但提交时**完全没有使用**这个配置，只取了第一个条件组的第一个条件 ID
- 导致用户在 UI 上配置的多条件、组间逻辑、排除条件全部失效

### 2.2 问题链：数据传递链路断裂

| 层级 | 文件 | 问题 | 严重程度 |
|------|------|------|---------|
| 前端构建器 | `upload.js:536-553` | ✅ 正确构建了复杂筛选配置 | 无问题 |
| 前端提交逻辑 | `upload.js:876-883` | ❌ 只传第一个条件 ID | 🔴 高 |
| 前端 API 封装 | `api.js:256-267` | ❌ 只支持单个 conditionId | 🔴 高 |
| 后端 API | `talents.py:350-353` | ❌ 只接收单个 condition_id | 🔴 高 |
| FilterNode | `filter_node.py` | ❌ 不支持条件组逻辑 | 🟡 中 |

### 2.3 数据结构不匹配

**前端构建的筛选配置结构**:
```javascript
{
    "groups": [
        {
            "logic": "and",           // 组内逻辑
            "condition_ids": ["id1", "id2"]  // 条件 ID 列表
        }
    ],
    "group_logic": "and",              // 组间逻辑
    "exclude_condition_ids": ["id4"]   // 排除条件
}
```

**后端期望的筛选配置结构**:
```python
{
    "skills": ["Python", "Java"],
    "education_level": "master",
    "experience_years": 5,
    "major": ["计算机"],
    "school_tier": "top"
}
```

**问题**: 前端传递的是**条件 ID 组合结构**，后端期望的是**具体条件字段**，两者完全不匹配。

### 2.4 高级筛选功能未实现

| 功能 | 前端支持 | 后端支持 | 状态 |
|------|---------|---------|------|
| 单条件筛选 | ✅ | ✅ | 已实现 |
| 条件组 | ✅ | ❌ | 未实现 |
| 组内逻辑 (AND/OR) | ✅ | ❌ | 未实现 |
| 组间逻辑 (AND/OR) | ✅ | ❌ | 未实现 |
| 排除条件 (NOT) | ✅ | ❌ | 未实现 |

## 三、修复方案

### 3.1 方案概述

采用**完整实现方案**，一次性解决所有问题：

1. **前端修改**: 传递完整的筛选配置，而非单个条件 ID
2. **后端 API 修改**: 接收并处理复杂筛选配置
3. **FilterNode 重构**: 实现条件组、组间逻辑、排除条件的完整筛选逻辑

### 3.2 详细修改清单

#### 3.2.1 前端修改

**文件**: `frontend-new/js/api.js`

修改 `batchUpload` 方法，支持传递完整筛选配置：

```javascript
/**
 * 批量上传简历
 * @param {FileList|File[]} files - 简历文件列表
 * @param {Object|string|null} filterConfig - 筛选配置对象或条件 ID
 */
async batchUpload(files, filterConfig = null) {
    const formData = new FormData();
    for (const file of files) {
        formData.append('files', file);
    }
    
    const params = new URLSearchParams();
    if (filterConfig) {
        if (typeof filterConfig === 'string') {
            // 向后兼容：直接是 condition_id
            params.append('condition_id', filterConfig);
        } else {
            // 新格式：完整筛选配置
            params.append('filter_config', JSON.stringify(filterConfig));
        }
    }
    
    const url = params.toString() 
        ? `/talents/batch-upload?${params.toString()}`
        : '/talents/batch-upload';

    return api.upload(url, formData);
}
```

**文件**: `frontend-new/js/pages/upload.js`

修改 `submitScreening` 方法，使用 `getFilterConfig()`：

```javascript
async submitScreening() {
    // ... 前面的代码保持不变 ...

    // 获取完整筛选配置
    const filterConfig = this.getFilterConfig();

    // 统一使用批量上传接口
    const response = await talentsApi.batchUpload(
        this.uploadedFiles,
        filterConfig  // 传递完整配置
    );

    // ... 后面的代码保持不变 ...
}
```

#### 3.2.2 后端 Schema 修改

**文件**: `src/schemas/condition.py`

新增筛选配置请求模型：

```python
class ConditionGroupRequest(BaseModel):
    """条件组请求模型。
    
    用于接收前端传递的条件组配置。
    
    Attributes:
        logic: 组内逻辑（and/or）。
        condition_ids: 条件 ID 列表。
    """
    
    logic: Literal["and", "or"] = Field(default="and", description="组内逻辑")
    condition_ids: list[str] = Field(default_factory=list, description="条件ID列表")


class FilterConfigRequest(BaseModel):
    """完整筛选配置请求模型。
    
    用于接收前端传递的复杂筛选配置。
    
    Attributes:
        groups: 条件组列表。
        group_logic: 组间逻辑（and/or）。
        exclude_condition_ids: 排除条件 ID 列表。
    """
    
    groups: list[ConditionGroupRequest] = Field(
        default_factory=list, 
        description="条件组列表"
    )
    group_logic: Literal["and", "or"] = Field(
        default="and", 
        description="组间逻辑"
    )
    exclude_condition_ids: list[str] = Field(
        default_factory=list, 
        description="排除条件ID列表"
    )
```

#### 3.2.3 后端 API 修改

**文件**: `src/api/v1/talents.py`

修改 `batch_upload` 和 `upload_and_screen` 接口：

```python
from src.schemas.condition import FilterConfigRequest

@router.post("/batch-upload")
async def batch_upload(
    files: Annotated[list[UploadFile], File(description="简历文件列表")],
    condition_id: Annotated[str | None, Query(description="筛选条件ID（向后兼容）")] = None,
    filter_config: Annotated[str | None, Query(description="筛选配置JSON")] = None,
) -> APIResponse[dict[str, Any]]:
    """批量上传简历。
    
    Args:
        files: 上传的简历文件列表
        condition_id: 筛选条件 ID（向后兼容）
        filter_config: 筛选配置 JSON（新格式）
    
    Returns:
        APIResponse[dict[str, Any]]: 包含任务 ID 的响应
    """
    # 解析筛选配置
    parsed_filter_config = None
    if filter_config:
        import json
        parsed_filter_config = json.loads(filter_config)
    elif condition_id:
        # 向后兼容：单个 condition_id 转换为简单配置
        parsed_filter_config = {"condition_id": condition_id}
    
    # ... 后续处理逻辑 ...
```

#### 3.2.4 工作流入口修改

**文件**: `src/workflows/resume_workflow.py`

修改 `run_resume_workflow` 函数，支持复杂筛选配置：

```python
async def run_resume_workflow(
    file_path: str,
    condition_id: str | None = None,
    condition_config: dict[str, Any] | None = None,
    filter_config: dict[str, Any] | None = None,  # 新增：复杂筛选配置
    content_hash: str | None = None,
) -> dict[str, Any]:
    """运行简历处理工作流。
    
    Args:
        file_path: 简历文件路径
        condition_id: 筛选条件 ID（向后兼容）
        condition_config: 筛选条件配置（向后兼容）
        filter_config: 复杂筛选配置（新格式）
        content_hash: 简历内容哈希
    """
    # 处理复杂筛选配置
    if filter_config and "groups" in filter_config:
        # 复杂筛选配置：加载所有条件并合并
        condition_config = await _load_and_merge_conditions(filter_config)
    elif not condition_config and condition_id:
        # 向后兼容：单个条件 ID
        condition_config = await _load_condition_by_id(condition_id)
    
    # ... 后续处理逻辑 ...
```

#### 3.2.5 FilterNode 重构

**文件**: `src/workflows/filter_node.py`

实现复杂筛选逻辑：

```python
async def filter_node(state: ResumeState) -> dict[str, Any]:
    """筛选节点。
    
    支持两种筛选模式：
    1. 简单模式：直接使用 condition_config 进行筛选
    2. 复杂模式：根据条件组、组间逻辑、排除条件进行筛选
    """
    # 检查是否有复杂筛选配置
    if state.filter_config and "groups" in state.filter_config:
        return await _complex_filter(state)
    
    # 简单筛选（向后兼容）
    return await _simple_filter(state)


async def _complex_filter(state: ResumeState) -> dict[str, Any]:
    """处理复杂筛选配置。
    
    实现条件组、组间逻辑、排除条件的完整筛选逻辑。
    """
    filter_config = state.filter_config
    groups = filter_config.get("groups", [])
    group_logic = filter_config.get("group_logic", "and")
    exclude_ids = filter_config.get("exclude_condition_ids", [])
    
    # 加载所有需要的条件配置
    all_condition_ids = set()
    for group in groups:
        all_condition_ids.update(group.get("condition_ids", []))
    all_condition_ids.update(exclude_ids)
    
    conditions_map = await _load_conditions_by_ids(all_condition_ids)
    
    # 评估每个条件组
    group_results = []
    for group in groups:
        group_result = await _evaluate_condition_group(
            state.candidate_info,
            group["condition_ids"],
            group["logic"],
            conditions_map
        )
        group_results.append(group_result)
    
    # 组间逻辑
    if group_logic == "and":
        is_qualified = all(r["is_qualified"] for r in group_results)
    else:
        is_qualified = any(r["is_qualified"] for r in group_results)
    
    # 排除条件
    if exclude_ids and is_qualified:
        exclude_result = await _evaluate_exclude_conditions(
            state.candidate_info,
            exclude_ids,
            conditions_map
        )
        is_qualified = not exclude_result
    
    return {
        "is_qualified": is_qualified,
        "qualification_reason": _build_qualification_reason(group_results, exclude_ids),
        "workflow_status": "filtered",
    }


async def _evaluate_condition_group(
    candidate_info: dict[str, Any],
    condition_ids: list[str],
    logic: str,
    conditions_map: dict[str, dict[str, Any]]
) -> dict[str, Any]:
    """评估单个条件组。
    
    Args:
        candidate_info: 候选人信息
        condition_ids: 条件 ID 列表
        logic: 组内逻辑（and/or）
        conditions_map: 条件配置映射
    
    Returns:
        dict[str, Any]: 评估结果
    """
    results = []
    for cond_id in condition_ids:
        cond_config = conditions_map.get(cond_id)
        if cond_config:
            result = _quick_filter(candidate_info, cond_config)
            if result is None:
                result = _call_llm_filter(candidate_info, cond_config)
            results.append(result)
    
    if logic == "and":
        is_qualified = all(r.is_qualified for r in results if r)
    else:
        is_qualified = any(r.is_qualified for r in results if r)
    
    return {
        "is_qualified": is_qualified,
        "results": results
    }
```

#### 3.2.6 状态模型修改

**文件**: `src/workflows/state.py`

新增 `filter_config` 字段：

```python
class ResumeState(BaseModel):
    """简历处理工作流状态。"""
    
    # ... 现有字段 ...
    
    # 筛选条件
    condition_id: str | None = Field(default=None, description="筛选条件 ID")
    condition_config: dict[str, Any] | None = Field(default=None, description="筛选条件配置")
    filter_config: dict[str, Any] | None = Field(default=None, description="复杂筛选配置（新格式）")
    
    # ... 其他字段 ...
```

## 四、修改文件清单

| 文件 | 修改类型 | 修改内容 |
|------|---------|---------|
| `frontend-new/js/api.js` | 修改 | `batchUpload` 方法支持复杂配置 |
| `frontend-new/js/pages/upload.js` | 修改 | `submitScreening` 使用 `getFilterConfig()` |
| `src/schemas/condition.py` | 新增 | `ConditionGroupRequest`、`FilterConfigRequest` 模型 |
| `src/api/v1/talents.py` | 修改 | `batch_upload`、`upload_and_screen` 接收复杂配置 |
| `src/workflows/state.py` | 修改 | 新增 `filter_config` 字段 |
| `src/workflows/resume_workflow.py` | 修改 | 支持复杂筛选配置 |
| `src/workflows/filter_node.py` | 重构 | 实现条件组、组间逻辑、排除条件 |

## 五、验证方案

### 5.1 测试用例

#### 测试 1：单条件筛选（向后兼容）

1. 创建一个筛选条件：工作年限 >= 5 年
2. 上传一份 3 年经验的简历
3. 预期结果：**未通过**（工作年限不足）

#### 测试 2：条件组内逻辑（AND）

1. 创建两个筛选条件：
   - 条件 A：工作年限 >= 5 年
   - 条件 B：学历 >= 硕士
2. 选择条件 A 和 B，组内逻辑 AND
3. 上传一份 6 年经验 + 本科学历的简历
4. 预期结果：**未通过**（学历不足）

#### 测试 3：条件组内逻辑（OR）

1. 创建两个筛选条件：
   - 条件 A：工作年限 >= 5 年
   - 条件 B：学历 >= 硕士
2. 选择条件 A 和 B，组内逻辑 OR
3. 上传一份 6 年经验 + 本科学历的简历
4. 预期结果：**通过**（满足条件 A）

#### 测试 4：组间逻辑（AND）

1. 创建三个筛选条件：
   - 条件 A：工作年限 >= 3 年
   - 条件 B：学历 >= 本科
   - 条件 C：技能包含 Python
2. 条件组 1：条件 A（AND）
3. 条件组 2：条件 B（AND）
4. 组间逻辑：AND
5. 上传一份 4 年经验 + 本科学历 + 无 Python 技能的简历
6. 预期结果：**未通过**（不满足条件 C）

#### 测试 5：组间逻辑（OR）

1. 创建两个筛选条件：
   - 条件 A：工作年限 >= 5 年
   - 条件 B：学历 >= 硕士
2. 条件组 1：条件 A（AND）
3. 条件组 2：条件 B（AND）
4. 组间逻辑：OR
5. 上传一份 3 年经验 + 硕士学历的简历
6. 预期结果：**通过**（满足条件组 2）

#### 测试 6：排除条件（NOT）

1. 创建两个筛选条件：
   - 条件 A：工作年限 >= 5 年
   - 条件 B：学历 >= 硕士
2. 选择条件 A，添加排除条件 B
3. 上传一份 6 年经验 + 硕士学历的简历
4. 预期结果：**未通过**（被排除条件过滤）

### 5.2 回归测试

确保修改不影响现有功能：
- 单个条件 ID 的筛选仍然正常工作
- 无筛选条件的简历上传正常工作
- 批量上传功能正常工作

## 六、风险评估

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|---------|
| 向后兼容性破坏 | 低 | 高 | 保留 `condition_id` 参数，优先使用 `filter_config` |
| 性能下降 | 中 | 中 | 批量加载条件配置，减少数据库查询 |
| LLM 调用增加 | 中 | 中 | 优化快速预筛选逻辑，减少 LLM 调用 |

## 七、实施步骤

1. **第一阶段：前端修改**
   - 修改 `api.js` 的 `batchUpload` 方法
   - 修改 `upload.js` 的 `submitScreening` 方法
   - 测试前端数据传递

2. **第二阶段：后端 Schema 和 API**
   - 新增 `FilterConfigRequest` 模型
   - 修改 `batch_upload` 和 `upload_and_screen` 接口
   - 测试 API 接收

3. **第三阶段：工作流和 FilterNode**
   - 修改 `ResumeState` 新增 `filter_config` 字段
   - 修改 `run_resume_workflow` 支持复杂配置
   - 重构 `filter_node` 实现复杂筛选逻辑
   - 测试完整筛选流程

4. **第四阶段：集成测试**
   - 执行所有测试用例
   - 回归测试
   - 性能测试

## 八、预期成果

修复完成后，简历上传页面将支持以下高级筛选功能：

1. **多条件组合筛选**：可选择多个筛选条件
2. **条件组内逻辑**：支持 AND/OR 逻辑
3. **组间逻辑**：支持多个条件组之间的 AND/OR 逻辑
4. **排除条件**：支持 NOT 逻辑排除特定候选人
5. **向后兼容**：单个条件 ID 的筛选仍然正常工作
