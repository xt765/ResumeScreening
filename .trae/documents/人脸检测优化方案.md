# 人脸检测优化方案

## 需求分析

在简历图片提取过程中，需要智能识别头像图片：
1. 首先使用现有的图片大小过滤（>1KB）
2. 如果过滤后只剩 1 张图片，直接返回（无需人脸检测）
3. 如果过滤后有多张图片，使用 OpenCV Haar 检测，保留最像人脸的那一张

## 技术方案

### 1. 添加依赖

在 `pyproject.toml` 中添加：
```toml
"opencv-python>=4.8.0",
```

### 2. 创建人脸检测工具

创建 `src/utils/face_detector.py`：

```python
"""人脸检测工具模块。

使用 OpenCV Haar 级联分类器检测图片中的人脸。
"""

import cv2
import numpy as np
from loguru import logger


class FaceDetector:
    """人脸检测器，用于识别头像图片。"""

    def __init__(self) -> None:
        """初始化人脸检测器，加载 Haar 级联分类器。"""
        self.face_cascade = cv2.CascadeClassifier(
            cv2.data.haarcascades + "haarcascade_frontalface_default.xml"
        )

    def detect_faces(self, image_bytes: bytes) -> list[tuple[int, int, int, int]]:
        """检测图片中的人脸位置。

        Args:
            image_bytes: 图片字节数据

        Returns:
            list[tuple]: 人脸位置列表 [(x, y, w, h), ...]
        """
        try:
            nparr = np.frombuffer(image_bytes, np.uint8)
            img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
            if img is None:
                return []

            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
            faces = self.face_cascade.detectMultiScale(
                gray,
                scaleFactor=1.1,
                minNeighbors=5,
                minSize=(30, 30),
            )
            return faces.tolist()
        except Exception as e:
            logger.warning(f"人脸检测失败: {e}")
            return []

    def get_face_score(self, image_bytes: bytes) -> float:
        """计算图片的人脸相似度得分。

        得分基于：
        - 检测到的人脸数量
        - 人脸区域大小
        - 人脸置信度

        Args:
            image_bytes: 图片字节数据

        Returns:
            float: 人脸相似度得分（0-100）
        """
        faces = self.detect_faces(image_bytes)
        if not faces:
            return 0.0

        # 计算得分：人脸数量 + 最大人脸面积占比
        nparr = np.frombuffer(image_bytes, np.uint8)
        img = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
        if img is None:
            return 0.0

        img_area = img.shape[0] * img.shape[1]
        max_face_area = max(w * h for (_, _, w, h) in faces)
        face_ratio = max_face_area / img_area if img_area > 0 else 0

        # 得分 = 人脸数量 * 20 + 人脸占比 * 80
        score = min(len(faces) * 20, 40) + min(face_ratio * 80, 60)
        return score

    def select_best_avatar(self, images: list[bytes]) -> int:
        """从多张图片中选择最像头像的那一张。

        Args:
            images: 图片字节列表

        Returns:
            int: 最佳图片的索引，如果没有检测到人脸则返回 0
        """
        if not images:
            return 0

        scores = [self.get_face_score(img) for img in images]
        best_idx = max(range(len(scores)), key=lambda i: scores[i])

        logger.info(
            f"人脸检测得分: {scores}, 最佳索引: {best_idx}, 得分: {scores[best_idx]}"
        )
        return best_idx


def filter_avatar_images(images: list[bytes]) -> list[bytes]:
    """过滤图片，保留最可能是头像的那一张。

    逻辑：
    1. 如果图片数量 <= 1，直接返回
    2. 如果图片数量 > 1，使用人脸检测选择最佳的一张

    Args:
        images: 图片字节列表（已通过大小过滤）

    Returns:
        list[bytes]: 过滤后的图片列表（最多 1 张）
    """
    if len(images) <= 1:
        return images

    detector = FaceDetector()
    best_idx = detector.select_best_avatar(images)

    return [images[best_idx]]
```

### 3. 修改解析节点

修改 `src/workflows/parse_extract_node.py`，在图片提取后添加人脸检测：

```python
# 在 _parse_pdf 和 _parse_docx 函数中，图片提取后添加：

from src.utils.face_detector import filter_avatar_images

# 现有代码：提取图片
images: list[bytes] = []
# ... 提取逻辑 ...

# 新增：过滤头像图片
if len(images) > 1:
    images = filter_avatar_images(images)
    logger.info(f"人脸检测过滤: 保留 {len(images)} 张头像图片")
```

### 4. 添加单元测试

创建 `tests/unit/test_face_detector.py`：

```python
"""人脸检测工具测试。"""

import pytest
from src.utils.face_detector import FaceDetector, filter_avatar_images


class TestFaceDetector:
    """人脸检测器测试。"""

    def test_detect_faces_no_face(self) -> None:
        """测试无人脸图片。"""
        # 创建一个纯色图片（无人脸）
        ...

    def test_detect_faces_with_face(self) -> None:
        """测试有人脸图片。"""
        # 使用测试图片
        ...

    def test_get_face_score(self) -> None:
        """测试人脸得分计算。"""
        ...

    def test_select_best_avatar(self) -> None:
        """测试选择最佳头像。"""
        ...


class TestFilterAvatarImages:
    """头像过滤测试。"""

    def test_filter_single_image(self) -> None:
        """测试单张图片直接返回。"""
        images = [b"fake_image_data"]
        result = filter_avatar_images(images)
        assert len(result) == 1

    def test_filter_empty_images(self) -> None:
        """测试空图片列表。"""
        result = filter_avatar_images([])
        assert result == []

    def test_filter_multiple_images(self) -> None:
        """测试多张图片选择最佳。"""
        ...
```

## 实现步骤

| 步骤 | 内容 | 文件 |
|------|------|------|
| 1 | 添加 opencv-python 依赖 | `pyproject.toml` |
| 2 | 创建人脸检测工具 | `src/utils/face_detector.py` |
| 3 | 更新模块导出 | `src/utils/__init__.py` |
| 4 | 修改 PDF 解析函数 | `src/workflows/parse_extract_node.py` |
| 5 | 修改 DOCX 解析函数 | `src/workflows/parse_extract_node.py` |
| 6 | 添加单元测试 | `tests/unit/test_face_detector.py` |
| 7 | 运行测试验证 | - |

## 注意事项

1. OpenCV Haar 级联分类器准确率约 70%，对于简单场景足够
2. 如果所有图片都检测不到人脸，返回第一张图片作为兜底
3. 人脸检测会增加约 50-100ms 的处理时间
4. 需要确保 `haarcascade_frontalface_default.xml` 模型文件可用（OpenCV 内置）
