# 前端页面切换性能优化计划

## 问题概述

用户反馈页面切换时显示很慢，经过深入分析代码，发现以下性能问题：

---

## 问题一：重复的事件监听器（严重）

### 问题分析

**位置**：所有 5 个页面模块都注册了 `hashchange` 事件监听器

| 文件 | 行号 | 代码片段 |
|------|------|----------|
| [dashboard.js](file:///d:/Documents/CodeProjects/ResumeScreening/frontend-new/js/pages/dashboard.js#L444) | `window.addEventListener('hashchange', ...)` |
| [upload.js](file:///d:/Documents/CodeProjects/ResumeScreening/frontend-new/js/pages/upload.js#L155) | `window.addEventListener('hashchange', ...)` |
| [talents.js](file:///d:/Documents/CodeProjects/ResumeScreening/frontend-new/js/pages/talents.js#L838) | `window.addEventListener('hashchange', ...)` |
| [analysis.js](file:///d:/Documents/CodeProjects/ResumeScreening/frontend-new/js/pages/analysis.js#L654) | `window.addEventListener('hashchange', ...)` |
| [conditions.js](file:///d:/Documents/CodeProjects/ResumeScreening/frontend-new/js/pages/conditions.js#L579) | `window.addEventListener('hashchange', ...)` |

**问题**：
- 每次路由变化触发 **5 个回调函数**
- 监听器永不移除，造成**内存泄漏**
- 即使只需要一个页面，所有页面都会执行判断逻辑

### 修复方案

**在 `app.js` 中统一管理路由事件**，移除各页面模块中的监听器：

```javascript
// app.js - 添加路由管理函数
function handleRouteChange() {
    const hash = window.location.hash.slice(1) || 'dashboard';
    const page = hash.split('/')[0];
    
    // 根据页面名称调用对应的初始化方法
    switch (page) {
        case 'dashboard':
            DashboardPage.initEvents();
            break;
        case 'upload':
            UploadPage.initEvents();
            break;
        case 'talents':
            TalentsPage.initEvents();
            break;
        case 'analysis':
            AnalysisPage.initEvents();
            break;
        case 'conditions':
            ConditionsPage.initEvents();
            break;
    }
}

// 只注册一次监听器
window.addEventListener('hashchange', handleRouteChange);
```

**移除各页面模块中的监听器**（保留 DOMContentLoaded 监听器用于首次加载）

---

## 问题二：路由循环触发（严重）

### 问题分析

**位置**： [app.js 第 56-92 行](file:///d:/Documents/CodeProjects/ResumeScreening/frontend-new/js/app.js#L56-L92)

```javascript
handleRouteChange() {
    // ...
    this.navigateTo(page);  // 调用 navigateTo
}

navigateTo(page) {
    // ...
    window.location.hash = `/${page}`;  // 设置 hash 会再次触发 hashchange！
}
```

**问题**：
1. `hashchange` 事件触发 → `handleRouteChange()` 被调用
2. `handleRouteChange()` 调用 `navigateTo()`
3. `navigateTo()` 设置 `window.location.hash`
4. 设置 hash 再次触发 `hashchange` 事件
5. 形成循环调用

### 修复方案

**在 `navigateTo()` 中检查当前 hash 是否已匹配目标页面**

```javascript
navigateTo(page) {
    const targetHash = `/${page}`;
    // 如果已经是目标页面，直接返回
    if (window.location.hash === targetHash) {
        return;
    }
    window.location.hash = targetHash;
}
```

---

## 问题三：阻塞式 API 调用（高）

### 问题分析

**位置**：各页面的 `render()` 方法

| 页面 | 文件位置 | API 调用 |
|------|----------|----------|
| Dashboard | [dashboard.js:13-31](file:///d:/Documents/CodeProjects/ResumeScreening/frontend-new/js/pages/dashboard.js#L13-L31) | `analysisApi.getStatistics()` |
| Talents | [talents.js:32-36](file:///d:/Documents/CodeProjects/ResumeScreening/frontend-new/js/pages/talents.js#L32-L36) | `loadConditions()` + `loadTalents()` |
| Upload | [upload.js:58-61](file:///d:/Documents/CodeProjects/ResumeScreening/frontend-new/js/pages/upload.js#L58-L61) | `loadConditions()` |
| Analysis | [analysis.js:15-18](file:///d:/Documents/CodeProjects/ResumeScreening/frontend-new/js/pages/analysis.js#L15-L18) | `loadStatistics()` |
| Conditions | [conditions.js:22-25](file:///d:/Documents/CodeProjects/ResumeScreening/frontend-new/js/pages/conditions.js#L22-L25) | `loadConditions()` |

**问题**：
- 页面切换必须等待 API 响应
- **无数据缓存**，每次切换都重新请求
- 用户长时间看到加载遮罩

### 修复方案

**实现非阻塞渲染 + 数据缓存**

1. **非阻塞渲染**：先渲染页面骨架，API 数据加载后再更新

```javascript
async render() {
    // 先返回骨架/占位内容
    const placeholder = this.renderPlaceholder();
    
    // 异步加载数据
    this.loadData().then(() => {
        this.updateContent();
    });
    
    return placeholder;
}
```

2. **数据缓存**：在页面模块中添加数据缓存机制

```javascript
// 页面模块中添加
data: null,
dataLoadedAt: null,
CACHE_DURATION: 5 * 60 * 1000, // 5分钟缓存

async loadData() {
    const now = Date.now();
    
    // 检查缓存是否有效
    if (this.data && this.dataLoadedAt) {
        const age = now - this.dataLoadedAt;
        if (age < this.CACHE_DURATION) {
            return; // 使用缓存数据
        }
    }
    
    // 加载新数据
    this.data = await this.fetchData();
    this.dataLoadedAt = now;
}
```

---

## 问题四：WebSocket 连接管理问题（中）

### 问题分析

**位置**： [upload.js 第 678-705 行](file:///d:/Documents/CodeProjects/ResumeScreening/frontend-new/js/pages/upload.js#L678-L705)

```javascript
initWebSocket() {
    this.ws = new WebSocket(wsUrl);
    
    this.ws.onclose = () => {
        setTimeout(() => this.initWebSocket(), 3000);  // 自动重连
    };
}
```

**问题**：
- 每次进入 upload 页面都尝试创建新 WebSocket
- 没有检查是否已有活跃连接
- 可能创建多个 WebSocket 连接

### 修复方案

**WebSocket 单例管理**：检查连接状态后再创建新连接

```javascript
initWebSocket() {
    // 检查是否已有活跃连接
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        return;
    }
    
    // 检查全局 WebSocket 实例
    if (window.sharedWebSocket && window.sharedWebSocket.readyState === WebSocket.OPEN) {
        this.ws = window.sharedWebSocket;
        return;
    }
    
    // 创建新连接
    this.ws = new WebSocket(wsUrl);
    window.sharedWebSocket = this.ws;
    
    this.ws.onclose = () => {
        if (window.sharedWebSocket === this.ws) {
            window.sharedWebSocket = null;
        }
        setTimeout(() => this.initWebSocket(), 3000);
    };
}
```

---

## 问题五：不必要的 setTimeout 延迟（中）

### 问题分析

**位置**：所有页面模块

```javascript
setTimeout(() => DashboardPage.initEvents(), 100);
setTimeout(() => TalentsPage.initEvents(), 100);
// ... 等等
```

**问题**：
- 100ms 延迟无实际意义
- 增加页面切换感知延迟
- 累计延迟可达数百毫秒

### 修复方案

**移除不必要的 setTimeout**：直接同步初始化事件

在统一路由管理后，不再需要 setTimeout 延迟

---

## 问题六：样式重复添加（低）

### 问题分析

**位置**：每个页面模块末尾

```javascript
const dashboardStyles = document.createElement('style');
document.head.appendChild(dashboardStyles);
```

**问题**：
- 每次页面 JS 加载都添加样式
- 页面切换多次后样式重复

### 修复方案

**检查样式是否已存在再添加**

```javascript
if (!document.getElementById('dashboard-styles')) {
    const style = document.createElement('style');
    style.id = 'dashboard-styles';
    style.textContent = `...`;
    document.head.appendChild(style);
}
```

---

## 修改文件清单

| 文件 | 修改内容 |
|------|----------|
| `frontend-new/js/app.js` | 统一路由管理、避免路由循环、优化 navigateTo |
| `frontend-new/js/pages/dashboard.js` | 移除 hashchange 监听器、添加数据缓存、非阻塞渲染 |
| `frontend-new/js/pages/upload.js` | 移除 hashchange 监听器、WebSocket 单例管理、非阻塞渲染 |
| `frontend-new/js/pages/talents.js` | 移除 hashchange 监听器、添加数据缓存、非阻塞渲染 |
| `frontend-new/js/pages/analysis.js` | 移除 hashchange 监听器、添加数据缓存、非阻塞渲染 |
| `frontend-new/js/pages/conditions.js` | 移除 hashchange 监听器、添加数据缓存、非阻塞渲染 |

---

## 实施步骤

1. **修复 app.js**
   - 添加统一路由管理函数
   - 修复 navigateTo 循环问题
   - 移除各页面的 hashchange 监听器注册

2. **修复各页面模块**
   - 添加数据缓存机制
   - 实现非阻塞渲染
   - 优化 WebSocket 连接管理（upload.js）
   - 优化样式添加逻辑

3. **测试验证**
   - 测试页面切换速度
   - 测试数据缓存效果
   - 测试 WebSocket 连接管理

---

## 预期效果

| 优化项 | 优化前 | 优化后 |
|--------|--------|--------|
| 页面切换响应 | 数百毫秒 | < 100ms |
| API 调用次数 | 每次切换都请求 | 5分钟内复用缓存 |
| 事件监听器 | 5个重复监听器 | 1个统一监听器 |
| WebSocket 连接 | 可能多个连接 | 单例管理 |
