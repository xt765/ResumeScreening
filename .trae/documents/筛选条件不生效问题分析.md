# 筛选条件不生效问题分析与解决方案

## 问题现象

用户反馈：设置 5 年以上工作经验的筛选条件，上传简历后 3 年经验的候选人也显示通过了。

## 问题根源分析

经过深入分析代码流程，发现问题的根本原因：

### 1. 数据流追踪

```
前端上传 → batch_upload API → run_resume_workflow → filter_node
```

### 2. 关键代码分析

**`batch_upload` 函数** (`src/api/v1/talents.py:462-466`)：
```python
result = await run_resume_workflow(
    file_path=temp_path,
    condition_id=condition_id,  # ✅ 传了 condition_id
    content_hash=content_hash,
    # ❌ 没有传 condition_config！
)
```

**`run_resume_workflow` 函数** (`src/workflows/resume_workflow.py:307-312`)：
```python
initial_state = ResumeState(
    file_path=file_path,
    condition_id=condition_id,
    condition_config=condition_config,  # ❌ 传入的是 None！
    content_hash=content_hash,
)
```

**`filter_node` 函数** (`src/workflows/filter_node.py:302-308`)：
```python
if not state.condition_config:
    logger.warning("筛选条件为空，默认通过筛选")
    return {
        "is_qualified": True,  # ❌ 直接通过！
        "qualification_reason": "无筛选条件，默认通过",
        "workflow_status": "filtered",
    }
```

### 3. 问题总结

| 步骤 | 问题 |
|------|------|
| 1. 前端上传 | ✅ 正确传递 condition_id |
| 2. batch_upload | ❌ 只传 condition_id，没有加载 condition_config |
| 3. run_resume_workflow | ❌ 没有根据 condition_id 加载 condition_config |
| 4. filter_node | ❌ condition_config 为空，默认通过 |

**根本原因**：`run_resume_workflow` 函数接收了 `condition_id`，但没有从数据库加载对应的 `condition_config`，导致 `filter_node` 收到的 `condition_config` 为 `None`，直接默认通过！

## 解决方案

### 方案一：在 `run_resume_workflow` 中加载条件配置（推荐）

修改 `src/workflows/resume_workflow.py`，在初始化状态前加载条件配置：

```python
async def run_resume_workflow(
    file_path: str,
    condition_id: str | None = None,
    condition_config: dict[str, Any] | None = None,
    content_hash: str | None = None,
) -> dict[str, Any]:
    # 如果没有传入 condition_config 但有 condition_id，从数据库加载
    if not condition_config and condition_id:
        from src.models import async_session_factory
        from src.models.condition import ScreeningCondition
        from sqlalchemy import select
        
        async with async_session_factory() as session:
            result = await session.execute(
                select(ScreeningCondition).where(ScreeningCondition.id == condition_id)
            )
            condition_record = result.scalar_one_or_none()
            if condition_record and condition_record.conditions:
                condition_config = condition_record.conditions
    
    # 初始化状态
    initial_state = ResumeState(
        file_path=file_path,
        condition_id=condition_id,
        condition_config=condition_config,
        content_hash=content_hash,
    )
    ...
```

### 方案二：在 `batch_upload` 中加载条件配置

修改 `src/api/v1/talents.py`，在调用工作流前加载条件配置：

```python
# 在 process_batch 函数内部
condition_config = None
if condition_id:
    async with async_session_factory() as session:
        result = await session.execute(
            select(ScreeningCondition).where(ScreeningCondition.id == condition_id)
        )
        condition_record = result.scalar_one_or_none()
        if condition_record and condition_record.conditions:
            condition_config = condition_record.conditions

result = await run_resume_workflow(
    file_path=temp_path,
    condition_id=condition_id,
    condition_config=condition_config,  # 传入加载的配置
    content_hash=content_hash,
)
```

## 推荐方案

**推荐方案一**，原因：
1. 修改点少，只需修改一个文件
2. 所有调用 `run_resume_workflow` 的地方都会自动受益
3. 符合单一职责原则，工作流自己负责加载所需的配置

## 文件修改清单

| 文件 | 修改内容 |
|------|----------|
| `src/workflows/resume_workflow.py` | 在 `run_resume_workflow` 中添加条件配置加载逻辑 |

## 验证步骤

1. 上传一份工作年限不足的简历
2. 检查日志确认 `condition_config` 已正确加载
3. 确认筛选结果为"未通过"
4. 确认筛选原因包含"工作年限不足"
